# Forked version of github.com/protobuf/protobuf/cmake protobuf-generate.cmake
# See the protobuf LICENSE for more details:
#
# Copyright 2008 Google Inc.  All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
#    * Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above
# copyright notice, this list of conditions and the following disclaimer
# in the documentation and/or other materials provided with the
# distribution.
#     * Neither the name of Google Inc. nor the names of its
# contributors may be used to endorse or promote products derived from
# this software without specific prior written permission.
#

# Invokes the protoc compiler on the .proto sources in a PROTO_TARGET, adding
# the generated outputs to the TARGET along with the computed import directories.
#
# btc_protobuf(
#   TARGET <source>
#     Add generated .proto sources to this target.
#
#   PROTO_TARGET <proto>
#     Resolve .proto files from the target INTERFACE_SOURCES.
#
#   PROTOS  <proto files>
#     Proto files
#
#   PROTOC_OPTIONS  <options list>
#     Addional options passed to protoc
#
#   LANGUAGE  <language>
#     Generated language, such as cpp, upb, etc. Should match the plugin.
#   GENERATE_EXTENSIONS  <extension list>
#     Extensions generated by the protoc compiler for each file.
#     For example, ".pb.h" ".pb.cc" are the cpp extensions.
#   PLUGIN  <plugin executable> 
#     Plugin executable name [empty for cpp]. Typically something like:
#     protoc-gen-${LANGUAGE}=$<TARGET_FILE:lanugage_plugin_target>
#   PLUGIN_OPTIONS
#    Options passed to the plugin.
#   PROTOC_OUT_DIR  <directory>
#     Output directory for generated .c/.h files
#
#   IMPORT_VARS <list>
#     List of variable used to reslove imports. For defined variables,
#     contents will be added to the import flags.
#
#   DEPENDS  <DEPENDS>
#     CMake DEPENDS.
#
#   VARNAME  <variable> 
#     Output generated files to this variable.
# )
function(btc_protobuf)
  include(CMakeParseArguments)

  set(_singleargs PROTO_TARGET LANGUAGE PROTOC_OUT_DIR PLUGIN PLUGIN_OPTIONS DEPENDS VARNAME)
  set(_multiargs PROTOS IMPORT_VARS GENERATE_EXTENSIONS PROTOC_OPTIONS)

  cmake_parse_arguments(btc "" "${_singleargs}" "${_multiargs}" "${ARGN}")

  if(NOT btc_LANGUAGE)
    set(btc_LANGUAGE cpp)
  endif()
  string(TOLOWER ${btc_LANGUAGE} btc_LANGUAGE)

  if(NOT btc_GENERATE_EXTENSIONS)
    message(SEND_ERROR "Error: btc_protobuf called without GENERATE_EXTENSIONS for LANGUAGE ${btc_LANGUAGE}.")
    return()
  endif()

  if(NOT btc_PROTO_TARGET)
    message(SEND_ERROR "Error: btc_protobuf called without a PROTO_TARGET.")
    return()
  endif()

  if(NOT btc_PROTOC_OUT_DIR)
    set(btc_PROTOC_OUT_DIR ${CMAKE_CURRENT_BINARY_DIR})
  else()
    file(MAKE_DIRECTORY ${btc_PROTOC_OUT_DIR})
  endif()

  # Get the sources from the PROTO_TARGET
  if(NOT btc_PROTOS)
    get_property(_source_list TARGET ${btc_PROTO_TARGET} PROPERTY INTERFACE_SOURCES)
    foreach(_file ${_source_list})
      if(_file MATCHES "proto$")
        list(APPEND btc_PROTOS ${_file})
      endif()
    endforeach()

    get_property(_source_list TARGET ${btc_PROTO_TARGET} PROPERTY SOURCES)
    foreach(_file ${_source_list})
      if(_file MATCHES "proto$")
        list(APPEND btc_PROTOS ${_file})
      endif()
    endforeach()
  endif()

  if(NOT btc_PROTOS)
    message(SEND_ERROR "Error: protobuf_generate could not find any .proto files.")
    return()
  endif()

  list(REMOVE_DUPLICATES btc_PROTOS)

  # Construct the plugin options.
  foreach(_option IN LISTS btc_PLUGIN_OPTIONS)
    # append comma - not using CMake lists and string replacement as users
    # might have semicolons in options
    if(_plugin_options)
      set( _plugin_options "${_plugin_options},")
    endif()
    set(_plugin_options "${_plugin_options}${_option}")
  endforeach()

  if(btc_PLUGIN)
    set(_plugin "--plugin=${btc_PLUGIN}")
  endif()

  # Construct transitive includes using generator expressions.
  # Using INTERFACE_LINK_LIBRARIES with generator expressions allows a
  # slightly less strict order of proto_library() target dependencies.
  #
  # The basic expression is:
  # foreach target in INTERFACE_LINK_LIBRARY:
  #   if target exists:
  #     foreach INTERFACE_INCLUDE_DIRECTORY in target:
  #       add -I;path;
  #
  # In addition, the INTERFACE_INCLUDE_DIRECTORIES will also be added without
  # using generator expressions.

  unset(_protobuf_transitive_include)
  btc_transitive_includes(
    PROTO_TARGET  ${btc_PROTO_TARGET}
    IMPORT_VARS   ${btc_IMPORT_VARS}
    VARNAME _protobuf_transitive_include
  )

  btc_basic_includes(
    PROTO_TARGET  ${btc_PROTO_TARGET}
    VARNAME _protobuf_include_path
  )

  list(PREPEND btc_DEPENDS "protobuf::protoc")
  list(REMOVE_DUPLICATES btc_DEPENDS)

  set(_generated_srcs_all)
  foreach(_proto ${btc_PROTOS})
    get_filename_component(_abs_file ${_proto} ABSOLUTE)
    get_filename_component(_abs_dir ${_abs_file} DIRECTORY)

    get_filename_component(_file_full_name ${_proto} NAME)
    string(FIND "${_file_full_name}" "." _file_last_ext_pos REVERSE)
    string(SUBSTRING "${_file_full_name}" 0 ${_file_last_ext_pos} _basename)

    set(_suitable_include_found FALSE)
    foreach(DIR ${_protobuf_include_path})
      if(NOT DIR STREQUAL "-I")
        file(RELATIVE_PATH _rel_dir ${DIR} ${_abs_dir})
        string(FIND "${_rel_dir}" "../" _is_in_parent_folder)
        if (NOT ${_is_in_parent_folder} EQUAL 0)
          set(_suitable_include_found TRUE)
          break()
        endif()
      endif()
    endforeach()

    if(NOT _suitable_include_found)
      message(SEND_ERROR "Error: btc_protobuf could not find any correct proto include directory.")
      return()
    endif()

    set(_generated_srcs)
    foreach(_ext ${btc_GENERATE_EXTENSIONS})
      list(APPEND _generated_srcs "${btc_PROTOC_OUT_DIR}/${_rel_dir}/${_basename}${_ext}")
    endforeach()
    list(APPEND _generated_srcs_all ${_generated_srcs})

    set(_comment "Running ${btc_LANGUAGE} protocol buffer compiler on ${_proto}")
    if(btc_PROTOC_OPTIONS)
      set(_comment "${_comment}, protoc-options: ${btc_PROTOC_OPTIONS}")
    endif()
    if(_plugin_options)
      set(_comment "${_comment}, plugin-options: ${_plugin_options}")
    endif()

    # message(STATUS "btc_protobuf: ${btc_VARNAME}  ${_generated_srcs}")
    add_custom_command(
      OUTPUT
          ${_generated_srcs}
      COMMAND protobuf::protoc
          ${btc_PROTOC_OPTIONS} --${btc_LANGUAGE}_out
          ${_plugin_options}:${btc_PROTOC_OUT_DIR}
          ${_plugin}
          ${_protobuf_include_path}
          "${_protobuf_transitive_include}"
          ${_abs_file}
      DEPENDS
          ${_abs_file} ${btc_DEPENDS} ${btc_PROTO_TARGET}
      COMMENT ${_comment}
      COMMAND_EXPAND_LISTS
      VERBATIM )
  endforeach()

  set_source_files_properties(${_generated_srcs_all} PROPERTIES GENERATED TRUE)

  if (btc_TARGET)
    target_sources(${btc_TARGET} PRIVATE ${_generated_srcs_all})
  endif()

  if(btc_VARNAME)
    set(${btc_VARNAME} "${_generated_srcs_all}" PARENT_SCOPE)
  endif()

endfunction()
