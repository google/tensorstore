// Copyright 2025 The TensorStore Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/// Golden file tests of the TIFF driver.
/// Verifies reading of TIFF files generated by the python script.

#include <gmock/gmock.h>
#include <gtest/gtest.h>
#include <stdint.h>

#include <nlohmann/json.hpp>
#include <optional>
#include <string>
#include <vector>

#include "absl/flags/flag.h"
#include "absl/log/absl_log.h"
#include "tensorstore/array.h"
#include "tensorstore/context.h"
#include "tensorstore/data_type.h"
#include "tensorstore/index.h"
#include "tensorstore/internal/path.h"
#include "tensorstore/open.h"
#include "tensorstore/open_mode.h"
#include "tensorstore/schema.h"
#include "tensorstore/spec.h"
#include "tensorstore/tensorstore.h"
#include "tensorstore/util/status.h"
#include "tensorstore/util/status_testutil.h"
#include "tensorstore/util/str_cat.h"

// Define the flag to locate the test data directory
ABSL_FLAG(std::string, tensorstore_test_data_dir, ".",
          "Path to directory containing TIFF test data.");

namespace {

using ::tensorstore::Context;
using ::tensorstore::dtype_v;
using ::tensorstore::Index;
using ::tensorstore::MatchesStatus;
using ::tensorstore::internal::IterationBufferPointer;
using ::testing::ElementsAreArray;
using ::testing::Optional;

// Helper function to generate expected data.
template <typename T>
tensorstore::SharedArray<T> MakeExpectedArray(
    tensorstore::span<const Index> shape) {
  auto array = tensorstore::AllocateArray<T>(shape);
  size_t count = 1;  // Start counting from 1

  constexpr bool use_modulo = std::is_integral_v<T>;
  T max_val = std::numeric_limits<T>::max();
  size_t modulo_divisor = 0;
  if (use_modulo) {
    uint64_t divisor_calc = static_cast<uint64_t>(max_val) + 1;
    if (divisor_calc > 0) {
      modulo_divisor = static_cast<size_t>(divisor_calc);
    }
  }

  tensorstore::IterateOverArrays(
      [&](tensorstore::ElementPointer<T> element_ptr) {
        T current_val;
        if (use_modulo && modulo_divisor != 0) {
          // Python: 1 -> 1, 255 -> 255, 256 -> 0, 257 -> 1
          // C++:   1%256=1, 255%256=255, 256%256=0, 257%256=1
          current_val = static_cast<T>(count % modulo_divisor);
        } else {
          current_val = static_cast<T>(count);
        }
        *(element_ptr.data()) = current_val;
        count++;
      },
      /*constraints=*/{}, array);
  return array;
}

// Structure to hold information for each test case
struct TestCaseInfo {
  std::string filename;
  ::nlohmann::json spec_override_json;
  tensorstore::DataType expected_dtype;
  std::vector<Index> expected_shape;
  std::vector<std::string> expected_labels;
  std::vector<Index> expected_chunk_shape;
};

class TiffGoldenFileTest : public ::testing::TestWithParam<TestCaseInfo> {
 public:
  std::string GetFullPath(const std::string& filename) {
    return tensorstore::internal::JoinPath(
        absl::GetFlag(FLAGS_tensorstore_test_data_dir), filename);
  }
};

TEST_P(TiffGoldenFileTest, ReadAndVerify) {
  const auto& test_info = GetParam();
  std::string full_path = GetFullPath(test_info.filename);
  ABSL_LOG(INFO) << "Testing TIFF file: " << full_path;
  ABSL_LOG(INFO) << "Spec overrides: " << test_info.spec_override_json.dump();

  ::nlohmann::json spec_json = {
      {"driver", "tiff"},
      {"kvstore", {{"driver", "file"}, {"path", full_path}}}};
  spec_json.update(test_info.spec_override_json);

  auto context = Context::Default();

  TENSORSTORE_ASSERT_OK_AND_ASSIGN(
      auto store,
      tensorstore::Open(spec_json, context, tensorstore::OpenMode::open,
                        tensorstore::ReadWriteMode::read)
          .result());

  ASSERT_EQ(test_info.expected_dtype, store.dtype());
  ASSERT_EQ(test_info.expected_shape.size(), store.rank());
  EXPECT_THAT(store.domain().origin(), ::testing::Each(0));
  EXPECT_THAT(store.domain().shape(),
              ElementsAreArray(test_info.expected_shape));
  if (!test_info.expected_labels.empty()) {
    EXPECT_THAT(store.domain().labels(),
                ElementsAreArray(test_info.expected_labels));
  }

  TENSORSTORE_ASSERT_OK_AND_ASSIGN(auto layout, store.chunk_layout());
  EXPECT_THAT(layout.read_chunk_shape(),
              ElementsAreArray(test_info.expected_chunk_shape));

  tensorstore::SharedArray<const void> expected_data;
  if (test_info.expected_dtype == dtype_v<uint8_t>) {
    expected_data = MakeExpectedArray<uint8_t>(test_info.expected_shape);
  } else if (test_info.expected_dtype == dtype_v<uint16_t>) {
    expected_data = MakeExpectedArray<uint16_t>(test_info.expected_shape);
  } else if (test_info.expected_dtype == dtype_v<int16_t>) {
    expected_data = MakeExpectedArray<int16_t>(test_info.expected_shape);
  } else if (test_info.expected_dtype == dtype_v<float>) {
    expected_data = MakeExpectedArray<float>(test_info.expected_shape);
  } else {
    FAIL() << "Unsupported dtype in test setup: " << test_info.expected_dtype;
  }

  TENSORSTORE_ASSERT_OK_AND_ASSIGN(auto read_data,
                                   tensorstore::Read(store).result());

  EXPECT_EQ(expected_data, read_data);
}

// Base dimensions H=32, W=48, Tile=16x16
const Index H = 32;
const Index W = 48;
const Index TH = 16;
const Index TW = 16;

const ::nlohmann::json kDefaultTiffSpec = {
    {"tiff", ::nlohmann::json::object()}};

INSTANTIATE_TEST_SUITE_P(
    GoldenFiles, TiffGoldenFileTest,
    ::testing::Values(
        // Case 1: Z=5, SPP=1, uint8 -> Rank 3 (Z, Y, X)
        TestCaseInfo{
            "single/stack_z5_spp1_uint8.tif",
            {{"tiff",
              {{"ifd_stacking", {{"dimensions", {"z"}}, {"ifd_count", 5}}}}}},
            dtype_v<uint8_t>,
            {5, H, W},        // Expected Shape (Z, Y, X)
            {"z", "y", "x"},  // Expected Labels (default order)
            {1, TH, TW}       // Expected Chunk Shape (Z, TileH, TileW)
        },
        // Case 2: Z=4, SPP=3 (RGB), uint16 -> Rank 4 (Z, Y, X, C)
        TestCaseInfo{
            "single/stack_z4_spp3_rgb_uint16.tif",
            {{
                "tiff",
                {{"ifd_stacking", {{"dimensions", {"z"}}, {"ifd_count", 4}}},
                 {"sample_dimension_label",
                  "c"}}  // Match default label assumption
            }},
            dtype_v<uint16_t>,
            {4, H, W, 3},          // Expected Shape (Z, Y, X, C)
            {"z", "y", "x", "c"},  // Expected Labels
            {1, TH, TW, 3}  // Expected Chunk Shape (Z, TileH, TileW, SPP)
        },
        // Case 3: T=2, C=3, SPP=1, float32 -> Rank 4 (T, C, Y, X) - Assuming
        // default label order t,c
        TestCaseInfo{
            "single/stack_t2_c3_spp1_float32.tif",
            {{"tiff",
              {{"ifd_stacking",
                {{"dimensions", {"t", "c"}}, {"dimension_sizes", {2, 3}}}}}}},
            dtype_v<float>,
            {2, 3, H, W},          // Expected Shape (T, C, Y, X)
            {"t", "c", "y", "x"},  // Expected Labels
            {1, 1, TH, TW}         // Expected Chunk Shape (T, C, TileH, TileW)
        },
        // Case 4: C=3, T=2, SPP=1, uint8, T fastest -> Rank 4 (C, T, Y, X)
        TestCaseInfo{
            "single/stack_c3_t2_spp1_t_fastest.tif",
            {{"tiff",
              {{"ifd_stacking",
                {{"dimensions", {"c", "t"}},
                 {"dimension_sizes", {3, 2}},
                 {"ifd_sequence_order", {"c", "t"}}}}}}},
            dtype_v<uint8_t>,
            {3, 2, H, W},          // Expected Shape (C, T, Y, X)
            {"c", "t", "y", "x"},  // Expected Labels
            {1, 1, TH, TW}         // Expected Chunk Shape (C, T, TileH, TileW)
        },
        TestCaseInfo{
            "single/stack_z3_spp1_uint8_stripped.tif",
            {{"tiff",
              {{"ifd_stacking", {{"dimensions", {"z"}}, {"ifd_count", 3}}}}}},
            dtype_v<uint8_t>,
            {3, H, W},        // Expected Shape (Z, Y, X)
            {"z", "y", "x"},  // Expected Labels
            {1, 32, W}},
        // Case 6: Single IFD, SPP=4 (RGBA), uint8 -> Rank 3 (Y, X, C)
        TestCaseInfo{
            "single/single_spp4_rgba_uint8.tif",
            {
                {"tiff",
                 {{"sample_dimension_label",
                   "rgba"}}},  // Specify label used by driver
                {"schema",
                 {{"domain",
                   {{"labels", {"y", "x", "rgba"}}}}}}  // Match driver default
                                                        // order Y,X,Sample
            },
            dtype_v<uint8_t>,
            {H, W, 4},           // Expected Shape (Y, X, RGBA)
            {"y", "x", "rgba"},  // Expected Labels
            {TH, TW, 4}          // Expected Chunk Shape (TileH, TileW, SPP)
        },
        // Case 8: Z=2, T=3, SPP=1, int16, T fastest -> Rank 4 (Z, T, Y, X)
        TestCaseInfo{
            "single/stack_z2_t3_spp1_int16.tif",
            {{"tiff",
              {{"ifd_stacking",
                {{"dimensions", {"z", "t"}},
                 {"dimension_sizes", {2, 3}},
                 {"ifd_sequence_order", {"z", "t"}}}}}}},
            dtype_v<int16_t>,
            {2, 3, H, W},          // Expected Shape (Z, T, Y, X)
            {"z", "t", "y", "x"},  // Expected Labels
            {1, 1, TH, TW}         // Expected Chunk Shape (Z, T, TileH, TileW)
        },
        // Case 9: Single IFD, uint8 -> Rank 2 (Y, X), ZStd compressed.
        TestCaseInfo{"single/single_zstd_uint8.tif",
                     nlohmann::json{{"tiff", nlohmann::json::object()}},
                     dtype_v<std::uint8_t>,
                     {H, W},
                     {"y", "x"},
                     {TH, TW}},
        // Case 10: Single IFD, uint8 -> Rank 2 (Y, X), Zlib compressed.
        TestCaseInfo{"single/single_zlib_uint8.tif",
                     nlohmann::json{{"tiff", nlohmann::json::object()}},
                     dtype_v<std::uint8_t>,
                     {H, W},
                     {"y", "x"},
                     {TH, TW}}));
}  // namespace
