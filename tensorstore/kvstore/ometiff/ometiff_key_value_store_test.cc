// Copyright 2023 The TensorStore Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "tensorstore/kvstore/ometiff/ometiff_key_value_store.h"

#include <gmock/gmock.h>
#include <gtest/gtest.h>

#include <numeric>
#include <vector>

#include "absl/log/globals.h"
#include "absl/log/log.h"
#include "absl/status/status.h"
#include "riegeli/bytes/string_reader.h"
#include "tensorstore/context.h"
#include "tensorstore/internal/intrusive_ptr.h"
#include "tensorstore/kvstore/driver.h"
#include "tensorstore/kvstore/memory/memory_key_value_store.h"
#include "tensorstore/kvstore/ometiff/ometiff_spec.h"
#include "tensorstore/util/status_testutil.h"

namespace {

namespace kvstore = tensorstore::kvstore;
using ::tensorstore::Result;
using ::tensorstore::ometiff::GetOMETiffKeyValueStore;
using ::tensorstore::ometiff::OMETiffMetadata;

Result<OMETiffMetadata> MetadataFromMemoryStore(const unsigned char* data,
                                                size_t size) {
  auto mem_store = tensorstore::GetMemoryKeyValueStore();
  TENSORSTORE_RETURN_IF_ERROR(mem_store->Write(
      "tiff",
      absl::Cord(absl::string_view(reinterpret_cast<const char*>(data), size)),
      kvstore::WriteOptions()));

  auto store = GetOMETiffKeyValueStore(mem_store, "tiff");
  TENSORSTORE_ASSIGN_OR_RETURN(auto result, store->Read("tiff").result());

  nlohmann::json raw_data =
      nlohmann::json::parse(result.value.Flatten(), nullptr, false);
  TENSORSTORE_ASSIGN_OR_RETURN(auto metadata,
                               OMETiffMetadata::FromJson(std::move(raw_data)));

  return std::move(metadata);
}

TEST(OMETiffKeyValueStoreTest, StripMetadata) {
  static constexpr unsigned char data[] = {
      0x49, 0x49, 0x2a, 0x00, 0x08, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x01,
      0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x01,
      0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x01,
      0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x03, 0x01,
      0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x06, 0x01,
      0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0e, 0x01,
      0x02, 0x00, 0x15, 0x00, 0x00, 0x00, 0xb6, 0x00, 0x00, 0x00, 0x11, 0x01,
      0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x15, 0x01,
      0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x16, 0x01,
      0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x17, 0x01,
      0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x1a, 0x01,
      0x05, 0x00, 0x01, 0x00, 0x00, 0x00, 0xda, 0x00, 0x00, 0x00, 0x1b, 0x01,
      0x05, 0x00, 0x01, 0x00, 0x00, 0x00, 0xe2, 0x00, 0x00, 0x00, 0x28, 0x01,
      0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x31, 0x01,
      0x02, 0x00, 0x0c, 0x00, 0x00, 0x00, 0xea, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x7b, 0x22, 0x73, 0x68, 0x61, 0x70, 0x65, 0x22, 0x3a, 0x20,
      0x5b, 0x31, 0x2c, 0x20, 0x31, 0x2c, 0x20, 0x31, 0x5d, 0x7d, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00,
      0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x74, 0x69, 0x66, 0x66, 0x66, 0x69,
      0x6c, 0x65, 0x2e, 0x70, 0x79, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00};

  TENSORSTORE_ASSERT_OK_AND_ASSIGN(auto metadata,
                                   MetadataFromMemoryStore(data, sizeof(data)));
  EXPECT_EQ(metadata.rank, 2);
  EXPECT_EQ(metadata.shape, std::vector<int64_t>({1, 1}));
  EXPECT_EQ(metadata.chunk_shape, std::vector<int64_t>({1, 1}));
  EXPECT_EQ(metadata.bits_per_sample, 8);
  EXPECT_EQ(metadata.samples_per_pixel, 1);
  EXPECT_EQ(metadata.is_tiled, 0);
  EXPECT_EQ(metadata.data_offset, 256);
  EXPECT_EQ(metadata.chunk_size, sizeof(uint8_t));
  EXPECT_EQ(metadata.compression, 1);  // COMPRESSION_NONE = 1
  EXPECT_EQ(metadata.dtype, tensorstore::dtype_v<uint8_t>);
}

TEST(OMETiffKeyValueStoreTest, TileMetadata) {
  static constexpr unsigned char data[] = {
      0x49, 0x49, 0x2a, 0x00, 0x08, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x01,
      0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x01, 0x01,
      0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x02, 0x01,
      0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x03, 0x01,
      0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x06, 0x01,
      0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0e, 0x01,
      0x02, 0x00, 0x17, 0x00, 0x00, 0x00, 0xc2, 0x00, 0x00, 0x00, 0x15, 0x01,
      0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x1a, 0x01,
      0x05, 0x00, 0x01, 0x00, 0x00, 0x00, 0xe8, 0x00, 0x00, 0x00, 0x1b, 0x01,
      0x05, 0x00, 0x01, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x28, 0x01,
      0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x31, 0x01,
      0x02, 0x00, 0x0c, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00, 0x42, 0x01,
      0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x43, 0x01,
      0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x44, 0x01,
      0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x10, 0x01, 0x00, 0x00, 0x45, 0x01,
      0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x7b, 0x22, 0x73, 0x68, 0x61, 0x70, 0x65, 0x22, 0x3a, 0x20,
      0x5b, 0x31, 0x36, 0x2c, 0x20, 0x31, 0x36, 0x2c, 0x20, 0x31, 0x5d, 0x7d,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x74, 0x69, 0x66, 0x66,
      0x66, 0x69, 0x6c, 0x65, 0x2e, 0x70, 0x79, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

  TENSORSTORE_ASSERT_OK_AND_ASSIGN(auto metadata,
                                   MetadataFromMemoryStore(data, sizeof(data)));
  EXPECT_EQ(metadata.rank, 2);
  EXPECT_EQ(metadata.shape, std::vector<int64_t>({16, 16}));
  EXPECT_EQ(metadata.chunk_shape, std::vector<int64_t>({16, 16}));
  EXPECT_EQ(metadata.bits_per_sample, 8);
  EXPECT_EQ(metadata.samples_per_pixel, 1);
  EXPECT_EQ(metadata.is_tiled, 1);
  EXPECT_EQ(metadata.data_offset, 272);
  EXPECT_EQ(metadata.chunk_size,
            sizeof(uint8_t) * 16 * 16);  // Min tile size is (16,16).
  EXPECT_EQ(metadata.compression, 1);    // COMPRESSION_NONE = 1
  EXPECT_EQ(metadata.dtype, tensorstore::dtype_v<uint8_t>);
}

}  // namespace
