# Copyright 2025 The TensorStore Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Based on the @rules_python//python/private/local_runtime_repo.bzl
#
"""Repository rule for Python local tool configuration.

`local_python_runtime` depends on the following environment variables:

  * `PYTHON_BIN_PATH`: location of python binary.
  * `TENSORSTORE_PYTHON_CONFIG_REPO`: location of remote python configuration repository.

There are three essential changes here compared to @rules_python/python/local_toolchains
and @rules_python/python/private/local_runtime_repo.bzl

1. The environment variable `PYTHON_BIN_PATH` overrides interpreter_path resolution;
   The environment variable `TENSORSTORE_PYTHON_CONFIG_REPO` overrides local configuration.

2. It happens before the @rules_python is loaded, so it cannot reference rules python.

"""

load(
    "//bazel/repo_rules:py_utils.bzl",
    "py_utils",
    _ENV_VARS = "ENV_VARS",
)
load(
    "//bazel/repo_rules:repo_utils.bzl",
    "repo_utils",
)

_TENSORSTORE_PYTHON_CONFIG_REPO = "TENSORSTORE_PYTHON_CONFIG_REPO"

_TOOLCHAIN_IMPL_TEMPLATE = """\
# Generated by python/python_configure.bzl

package(
    default_visibility = ["//visibility:public"],
)

load("@rules_python//python/private:local_runtime_repo_setup.bzl", "define_local_runtime_toolchain_impl")

define_local_runtime_toolchain_impl(
    name = "local_runtime",
    lib_ext = "{lib_ext}",
    major = "{major}",
    minor = "{minor}",
    micro = "{micro}",
    interpreter_path = "{interpreter_path}",
    implementation_name = "{implementation_name}",
    os = "{os}",
)

"""

def _local_python_repo_impl(rctx):
    """Implementation of the local_python_repo repository rule."""
    if _TENSORSTORE_PYTHON_CONFIG_REPO in rctx.os.environ:
        remote_config_repo = rctx.os.environ[_TENSORSTORE_PYTHON_CONFIG_REPO]
        rctx.template("BUILD", Label(remote_config_repo + ":BUILD"), {})
        return

    # Otherwise creates the repository containing files set up to build with Python."""
    logger = repo_utils.logger(rctx)

    result = py_utils.get_python_interpreter(rctx, rctx.attr.interpreter_path)
    if not result.resolved_path:
        logger.fail(lambda: "interpreter not found: {}".format(result.describe_failure()))
        return
    else:
        interpreter_path = result.resolved_path

    result = py_utils.get_python_info(
        rctx,
        interpreter_path = interpreter_path,
        logger = logger,
    )
    if not result.info:
        logger.fail(lambda: "GetPythonInfo failed: {}".format(result.describe_failure()))
        return
    else:
        info = result.info

    # Example of a GetPythonInfo result from macos:
    # {
    #    "major": 3,
    #    "minor": 12,
    #    "micro": 10,
    #    "implementation_name": "cpython",
    #    "base_executable": "/Library/Frameworks/Python.framework/Versions/3.12/bin/python3.12",
    #    "include": "/Library/Frameworks/Python.framework/Versions/3.12/include/python3.12",
    #    "numpy_include": "/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages/numpy/_core/include",
    #    "LDLIBRARY": "Python.framework/Versions/3.12/Python",
    #    "LIBDIR": "/Library/Frameworks/Python.framework/Versions/3.12/lib",
    #    "INSTSONAME": "Python.framework/Versions/3.12/Python",
    #    "PY3LIBRARY": "",
    #    "SHLIB_SUFFIX": ".so",
    # }
    #
    # We use base_executable because we want the path within a Python
    # installation directory ("PYTHONHOME"). The problems with sys.executable
    # are:
    # * If we're in an activated venv, then we don't want the venv's
    #   `bin/python3` path to be used -- it isn't an actual Python installation.
    # * If sys.executable is a wrapper (e.g. pyenv), then (1) it may not be
    #   located within an actual Python installation directory, and (2) it
    #   can interfer with Python recognizing when it's within a venv.
    #
    # In some cases, it may be a symlink (usually e.g. `python3->python3.12`),
    # but we don't realpath() it to respect what it has decided is the
    # appropriate path.
    interpreter_path = info["base_executable"]

    # NOTE: Keep in sync with recursive glob in define_local_runtime_toolchain_impl
    repo_utils.watch_tree(rctx, rctx.path(info["include"]))

    # The cc_library.includes values have to be non-absolute paths, otherwise
    # the toolchain will give an error. Work around this error by making them
    # appear as part of this repo.
    include_src = repo_utils.norm_path(info["include"])
    numpy_include_src = include_src + "/numpy/"
    for src in sorted(repo_utils.read_dir(rctx, include_src, logger)):
        if src.startswith(numpy_include_src):
            continue
        dest = src.replace(include_src, "include")
        rctx.symlink(src, dest)

    shared_lib_names = [
        info["PY3LIBRARY"],
        info["LDLIBRARY"],
        info["INSTSONAME"],
    ]

    # In some cases, the value may be empty. Not clear why.
    shared_lib_names = [v for v in shared_lib_names if v]

    # In some cases, the same value is returned for multiple keys. Not clear why.
    shared_lib_names = {v: None for v in shared_lib_names}.keys()
    shared_lib_dir = info["LIBDIR"]

    # The specific files are symlinked instead of the whole directory
    # because it can point to a directory that has more than just
    # the Python runtime shared libraries, e.g. /usr/lib, or a Python
    # specific directory with pip-installed shared libraries.
    rctx.report_progress("Symlinking external Python shared libraries")
    for name in shared_lib_names:
        origin = rctx.path("{}/{}".format(shared_lib_dir, name))

        # The reported names don't always exist; it depends on the particulars
        # of the runtime installation.
        if origin.exists:
            repo_utils.watch(rctx, origin)
            rctx.symlink(origin, "lib/" + name)

    rctx.file("WORKSPACE", "")
    rctx.file("MODULE.bazel", "")
    rctx.file("REPO.bazel", "")
    rctx.file("BUILD.bazel", _TOOLCHAIN_IMPL_TEMPLATE.format(
        major = info["major"],
        minor = info["minor"],
        micro = info["micro"],
        interpreter_path = interpreter_path,
        lib_ext = info["SHLIB_SUFFIX"],
        implementation_name = info["implementation_name"],
        os = "@platforms//os:{}".format(repo_utils.get_platforms_os_name(rctx)),
    ))

# Public python attributes.
python_attrs = {
    "interpreter_path": attr.string(
        doc = """
An absolute path or program name on the `PATH` env var.

Values with slashes are assumed to be the path to a program. Otherwise, it is
treated as something to search for on `PATH`

Note that, when a plain program name is used, the path to the interpreter is
resolved at repository evalution time, not runtime of any resulting binaries.
""",
    ),
    "_get_runtime_info": attr.label(
        allow_single_file = True,
        default = "//bazel/repo_rules:get_local_runtime_info.py",
    ),
}

# Environment variables that are used by python_configure.
PYTHON_ENV_VARS = _ENV_VARS + [
    # When provided, the value of this environment variable is used to
    # determine whether to use the remote python configuration repository.
    _TENSORSTORE_PYTHON_CONFIG_REPO,
]

local_python_runtime = repository_rule(
    implementation = _local_python_repo_impl,
    local = True,
    configure = True,
    attrs = python_attrs | {
        "_rule_name": attr.string(default = "local_python_runtime"),
    },
    environ = PYTHON_ENV_VARS,
    doc = """\
Detects and configures the local Python.

Add the following to your WORKSPACE FILE:

```python
local_python_runtime(name = "local_config_python")
```

Args:
  name: A unique name for this workspace rule.
""",
)
