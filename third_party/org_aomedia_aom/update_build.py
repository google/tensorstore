#!/usr/bin/env python3

# Copyright 2026 The TensorStore Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""Update the libaom BUILD files.

This script should be run after updating the libaom archive
and running update_libaom.py.

It reads the libaom_srcs.bzl file generated by update_libaom.py and generates
a BUILD file for the libaom sources.

When generating configs, review the chromium source:
https://chromium.googlesource.com/chromium/src/+/refs/heads/main/third_party/libaom
"""

import argparse
import ast
import io
import os
import pathlib
import subprocess
from typing import NamedTuple


_IGNORE_TARGETS = [
    "aom_encoder_app_util_sources",
    "aom_decoder_app_util_sources",
    "aom_common_app_util_sources",
    "aom_webm_decoder_sources",
    "aom_webm_encoder_sources",
    "aom_libwebm_sources",
    "aom_encoder_stats_sources",
    "aom_decoder_stats_sources",
    "aom_av1_common_intrin_ssse3_x86",  # 32-bit SSE3 intrinsics not supported.
]

_KIND_TO_PLATFORM = {
    "_nasm": "@platforms//cpu:x86_64",
    "_avx": "@platforms//cpu:x86_64",
    "_avx2": ":have_avx2_intrinsics",
    "_sse2": "@platforms//cpu:x86_64",
    "_sse2_x86_64": "@platforms//cpu:x86_64",
    "_sse3": "@platforms//cpu:x86_64",
    "_sse4_1": "@platforms//cpu:x86_64",
    "_sse4_2": "@platforms//cpu:x86_64",
    "_ssse3": "@platforms//cpu:x86_64",
    "_ssse3_x86_64": "@platforms//cpu:x86_64",
    # Arm
    "_arm_crc32": "@platforms//cpu:arm64",
    "_neon": "@platforms//cpu:arm64",
    "_neon_dotprod": "@platforms//cpu:arm64",
    "_neon_i8mm": "@platforms//cpu:arm64",
    "_sve": ":have_sve2_intrinsics",
    "_sve2": ":have_sve2_intrinsics",
    # PPC
    "_vsx": "@platforms//cpu:ppc",
}

_KIND_TO_COPTS = {
    "_neon_dotprod": "-march=armv8.2-a+dotprod",
    "_neon_i8mm": "-march=armv8.2-a+dotprod+i8mm",
    "_sve": "-march=armv8.2-a+dotprod+i8mm+sve",
    "_sve2": "-march=armv9-a+i8mm+sve2",
}

_ERRORS: list[str] = []


class _Target(NamedTuple):
  name: str
  kind: str  # Indicates the set of build constraints used.
  srcs: tuple[str, ...]
  hdrs: tuple[str, ...]


def _load_libaom_srcs(config_dir: pathlib.Path) -> dict[str, _Target]:
  """Loads the libaom sources from the libaom_srcs.bzl file.

  Note that this file is autogenerated by the cmake invocation for libaom.
  """

  targets: dict[str, _Target] = {}

  def _process_source_list(name: str, elts: list[ast.expr]):
    if name.endswith("_rvv"):
      # skip RISC-V sources: No RISC-V build support yet.
      return

    if name in _IGNORE_TARGETS:
      # skip ignored targets
      return

    kind = None
    if "_asm_" in name:
      kind = "_nasm"
    else:
      for k in _KIND_TO_PLATFORM:
        if name.endswith(k):
          kind = k
          break

    if kind is None and not name.endswith("_sources"):
      _ERRORS.append(f"Unknown target kind for {name}")
      return

    name = name.removesuffix("_sources")

    hdrs = set()
    srcs = set()
    for x in elts:
      v = x.value
      if v.endswith(".h"):
        hdrs.add(v)
      elif v.endswith(".c") or v.endswith(".asm") or v.endswith(".S"):
        srcs.add(v)

    t = _Target(
        name=name,
        kind=kind,
        srcs=tuple(sorted(srcs)),
        hdrs=tuple(sorted(hdrs)),
    )

    targets[name] = t

  src_text = (config_dir / "libaom_srcs.bzl").read_text(encoding="utf-8")
  for node in ast.parse(src_text).body:
    if isinstance(node, ast.Assign) and len(node.targets) == 1:
      target = node.targets[0]
      if isinstance(target, ast.Name) and isinstance(node.value, ast.List):
        _process_source_list(target.id, node.value.elts)

  return targets


def _combine_targets(targets: dict[str, _Target]) -> dict[str, _Target]:
  """Combines the source targets according to required build constraints.

  This results in a set of targets closely matching the libaom build
  in the chromium source tree and allows the build to avoid tracking
  internal libaom dependencies.
  """

  def _combine_t(
      name: str, kind: str | None, a: _Target | None, b: _Target | None
  ) -> _Target:
    srcs = set()
    hdrs = set()
    if a:
      srcs.update(a.srcs)
      hdrs.update(a.hdrs)
    if b:
      srcs.update(b.srcs)
      hdrs.update(b.hdrs)
    return _Target(
        name=name,
        kind=kind,
        srcs=tuple(sorted(srcs)),
        hdrs=tuple(sorted(hdrs)),
    )

  new_targets: dict[str, _Target] = {}

  for v in targets.values():
    # All the x86 SSE files can be combined into a single target since
    # approximately all SSE flags are enabled during the build.
    if v.kind in (
        "_sse2",
        "_sse2_x86",
        "_sse2_x86_64",
        "_sse3",
        "_sse4_1",
        "_sse4_2",
        "_ssse3",
        "_ssse3_x86_64",
        "_ssse3_x86",
    ):
      # Default x86_64 targets merge these into a single target.
      combined = "aom_intrinsics_sse4_2"
      new_kind = "_sse4_2"
    elif v.kind in (
        "_arm_crc32",
        "_neon",
    ):
      # Default arm64 targets merge these into a single target.
      combined = "aom_intrinsics_neon"
      new_kind = "_neon"
    elif v.kind is not None:
      combined = "aom_intrinsics" + v.kind
      new_kind = v.kind
    else:
      combined = "aom"
      new_kind = None

    # Combine all targets with the same kind into a single target.
    new_targets[combined] = _combine_t(
        combined, new_kind, new_targets.get(combined), v
    )
  return new_targets


def _emit_nasm_cc_library(t: _Target, out: io.StringIO):
  out.write("nasm_cc_library(\n")
  out.write(f"    name = {repr(t.name)},\n")
  out.write("    srcs = [\n")
  for s in t.srcs:
    out.write(f'        "{s}",\n')
  out.write("    ],\n")
  out.write("    hdrs = NASM_HDRS,\n")
  out.write("    copts = NASM_COPTS,\n")
  out.write("    alwayslink = 1,\n")
  out.write(")\n\n")


def _emit_cc_library_with_constraint(t: _Target, out: io.StringIO):

  copt = _KIND_TO_COPTS.get(t.kind)
  extra_copts = {
      "_sse4_2": "+ LIBAOM_COPTS_BASELINE",
      "_avx": "+ LIBAOM_COPTS_AVX",
      "_avx2": "+ LIBAOM_COPTS_AVX2",
  }.get(t.kind, "")

  out.write("cc_library(\n")
  out.write(f'    name = "{t.name}",\n')
  out.write("    srcs = [\n")
  for s in t.srcs:
    out.write(f'        "{s}",\n')
  out.write("    ],\n")
  if t.hdrs and t.kind is None:
    # :config exposes all the required headers, so omit them here.
    out.write("    hdrs = [\n")
    for s in t.hdrs:
      out.write(f'        "{s}",\n')
    out.write("    ],\n")
  if copt:
    out.write(f'    copts = LIBAOM_COPTS + ["{copt}"],\n')
  else:
    out.write(f"    copts = LIBAOM_COPTS{extra_copts},\n")
  out.write("    deps = [\n")
  out.write('        ":config",\n')
  out.write("    ],\n")
  out.write("    alwayslink = 1,\n")
  out.write(")\n\n")


def _emit_cc_library(
    t: _Target, deps: dict[str | None, list[str]], out: io.StringIO
):
  out.write("cc_library(\n")
  out.write(f'    name = "{t.name}",\n')
  if t.srcs:
    out.write("    srcs = [\n")
    for s in t.srcs:
      out.write(f'        "{s}",\n')
    out.write("    ],\n")
  if t.hdrs:
    out.write("    hdrs = [\n")
    for s in t.hdrs:
      out.write(f'        "{s}",\n')
    out.write("    ],\n")
  out.write("    copts = LIBAOM_COPTS,\n")
  out.write("    deps = [\n")
  for x in sorted(deps[None]):
    out.write(f'        ":{x}",\n')
  out.write("    ]")
  if len(deps) > 1:
    for k, v in deps.items():
      if not v or k is None:
        continue
      out.write(
          "+ select({\n"
          '      "//conditions:default": [],\n'
          f'      "{k}": [\n'
      )
      for x in v:
        out.write(f'        ":{x}",\n')
      out.write("    ]\n})")
  out.write(",\n")
  out.write("    alwayslink = 1,\n")
  out.write(")\n\n")


def _generate_build_file(targets: dict[str, _Target], out: io.StringIO):
  """Generates the build file for the libaom sources."""

  # Emit all the constrained targets first.
  for t in targets.values():
    if t.kind is None:
      continue
    if t.kind == "_nasm":
      _emit_nasm_cc_library(t, out)
    else:
      assert t.kind in _KIND_TO_PLATFORM
      _emit_cc_library_with_constraint(t, out)

  # Emit all the unconstrained targets.
  for t in targets.values():
    if t.kind is not None:
      continue
    deps: dict[str | None, list[str]] = {}
    deps[None] = ["config"]

    # collect deps, which depends on the library naming convention
    for u in targets.values():
      if u.kind is None:
        continue
      if not u.name.startswith(t.name):
        continue
      p = _KIND_TO_PLATFORM.get(u.kind)
      deps.setdefault(p, []).append(u.name)

    _emit_cc_library(t, deps, out)


def main():
  ap = argparse.ArgumentParser()
  ap.add_argument(
      "--config-dir",
      type=pathlib.Path,
      default=pathlib.Path(
          os.path.dirname(os.path.realpath(__file__)) + "/generated_configs"
      ),
      help="Output paths for the generated configs.",
  )
  ap.add_argument(
      "--build-file",
      type=pathlib.Path,
      default=pathlib.Path(
          os.path.dirname(os.path.realpath(__file__)) + "/libaom.BUILD.bazel"
      ),
      help="Path to the libaom.BUILD.bazel file.",
  )
  ap.add_argument(
      "--dry-run",
      action="store_true",
      help="Skip overwriting the build file.",
  )
  args, remaining_args = ap.parse_known_args()

  if not args.config_dir.exists():
    raise ValueError("--config-dir is required.")

  targets = _load_libaom_srcs(args.config_dir)
  targets = _combine_targets(targets)

  if _ERRORS:
    msg = "\n".join(_ERRORS)
    print(f"The following errors were encountered:\n{msg}")
    raise ValueError(msg)

  out = io.StringIO()
  if args.build_file.exists():
    # Copy the existing build file to the output, stopping at the autogen line.
    for x in args.build_file.read_text(encoding="utf-8").splitlines():
      if x.find("AUTOGENERATED BELOW THIS LINE") != -1:
        break
      out.write(x)
      out.write("\n")

  out.write("# AUTOGENERATED BELOW THIS LINE by update_build.py\n\n")
  _generate_build_file(targets, out)

  if args.build_file and not args.dry_run:
    args.build_file.write_text(out.getvalue(), encoding="utf-8")
    subprocess.call(["buildifier", args.build_file])
  else:
    print(out.getvalue())


if __name__ == "__main__":
  main()
